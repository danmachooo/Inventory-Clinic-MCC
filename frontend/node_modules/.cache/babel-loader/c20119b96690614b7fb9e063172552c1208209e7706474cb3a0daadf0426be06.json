{"ast":null,"code":"import _toConsumableArray from \"C:/Inventory-Clinic-MCC/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Inventory-Clinic-MCC/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Inventory-Clinic-MCC/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createClass from \"C:/Inventory-Clinic-MCC/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Inventory-Clinic-MCC/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _defineProperty from \"C:/Inventory-Clinic-MCC/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n  return index;\n};\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n  var start = Math.max(range.startIndex - range.overscan, 0);\n  var end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  var arr = [];\n  for (var i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nvar observeElementRect = function observeElementRect(instance, cb) {\n  var element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  var targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  var handler = function handler(rect) {\n    var width = rect.width,\n      height = rect.height;\n    cb({\n      width: Math.round(width),\n      height: Math.round(height)\n    });\n  };\n  handler(element.getBoundingClientRect());\n  if (!targetWindow.ResizeObserver) {\n    return function () {};\n  }\n  var observer = new targetWindow.ResizeObserver(function (entries) {\n    var entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      var box = entry.borderBoxSize[0];\n      if (box) {\n        handler({\n          width: box.inlineSize,\n          height: box.blockSize\n        });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, {\n    box: \"border-box\"\n  });\n  return function () {\n    observer.unobserve(element);\n  };\n};\nvar addEventListenerOptions = {\n  passive: true\n};\nvar observeWindowRect = function observeWindowRect(instance, cb) {\n  var element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  var handler = function handler() {\n    cb({\n      width: element.innerWidth,\n      height: element.innerHeight\n    });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return function () {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nvar supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nvar observeElementOffset = function observeElementOffset(instance, cb) {\n  var element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  var targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  var offset = 0;\n  var fallback = instance.options.useScrollendEvent && supportsScrollend ? function () {\n    return void 0;\n  } : debounce(targetWindow, function () {\n    cb(offset, false);\n  }, instance.options.isScrollingResetDelay);\n  var createHandler = function createHandler(isScrolling) {\n    return function () {\n      var _instance$options = instance.options,\n        horizontal = _instance$options.horizontal,\n        isRtl = _instance$options.isRtl;\n      offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n      fallback();\n      cb(offset, isScrolling);\n    };\n  };\n  var handler = createHandler(true);\n  var endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  return function () {\n    element.removeEventListener(\"scroll\", handler);\n    element.removeEventListener(\"scrollend\", endHandler);\n  };\n};\nvar observeWindowOffset = function observeWindowOffset(instance, cb) {\n  var element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  var targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  var offset = 0;\n  var fallback = instance.options.useScrollendEvent && supportsScrollend ? function () {\n    return void 0;\n  } : debounce(targetWindow, function () {\n    cb(offset, false);\n  }, instance.options.isScrollingResetDelay);\n  var createHandler = function createHandler(isScrolling) {\n    return function () {\n      offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n      fallback();\n      cb(offset, isScrolling);\n    };\n  };\n  var handler = createHandler(true);\n  var endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  return function () {\n    element.removeEventListener(\"scroll\", handler);\n    element.removeEventListener(\"scrollend\", endHandler);\n  };\n};\nvar measureElement = function measureElement(element, entry, instance) {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    var box = entry.borderBoxSize[0];\n    if (box) {\n      var size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n      return size;\n    }\n  }\n  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nvar windowScroll = function windowScroll(offset, _ref, instance) {\n  var _ref$adjustments = _ref.adjustments,\n    adjustments = _ref$adjustments === void 0 ? 0 : _ref$adjustments,\n    behavior = _ref.behavior;\n  var _a, _b;\n  var toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, _defineProperty(_defineProperty({}, instance.options.horizontal ? \"left\" : \"top\", toOffset), \"behavior\", behavior));\n};\nvar elementScroll = function elementScroll(offset, _ref2, instance) {\n  var _ref2$adjustments = _ref2.adjustments,\n    adjustments = _ref2$adjustments === void 0 ? 0 : _ref2$adjustments,\n    behavior = _ref2.behavior;\n  var _a, _b;\n  var toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, _defineProperty(_defineProperty({}, instance.options.horizontal ? \"left\" : \"top\", toOffset), \"behavior\", behavior));\n};\nvar Virtualizer = /*#__PURE__*/_createClass(function Virtualizer(opts) {\n  var _this = this;\n  _classCallCheck(this, Virtualizer);\n  this.unsubs = [];\n  this.scrollElement = null;\n  this.targetWindow = null;\n  this.isScrolling = false;\n  this.scrollToIndexTimeoutId = null;\n  this.measurementsCache = [];\n  this.itemSizeCache = /* @__PURE__ */new Map();\n  this.pendingMeasuredCacheIndexes = [];\n  this.scrollRect = null;\n  this.scrollOffset = null;\n  this.scrollDirection = null;\n  this.scrollAdjustments = 0;\n  this.elementsCache = /* @__PURE__ */new Map();\n  this.observer = /* @__PURE__ */function () {\n    var _ro = null;\n    var get = function get() {\n      if (_ro) {\n        return _ro;\n      }\n      if (!_this.targetWindow || !_this.targetWindow.ResizeObserver) {\n        return null;\n      }\n      return _ro = new _this.targetWindow.ResizeObserver(function (entries) {\n        entries.forEach(function (entry) {\n          _this._measureElement(entry.target, entry);\n        });\n      });\n    };\n    return {\n      disconnect: function disconnect() {\n        var _a;\n        (_a = get()) == null ? void 0 : _a.disconnect();\n        _ro = null;\n      },\n      observe: function observe(target) {\n        var _a;\n        return (_a = get()) == null ? void 0 : _a.observe(target, {\n          box: \"border-box\"\n        });\n      },\n      unobserve: function unobserve(target) {\n        var _a;\n        return (_a = get()) == null ? void 0 : _a.unobserve(target);\n      }\n    };\n  }();\n  this.range = null;\n  this.setOptions = function (opts2) {\n    Object.entries(opts2).forEach(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        key = _ref4[0],\n        value = _ref4[1];\n      if (typeof value === \"undefined\") delete opts2[key];\n    });\n    _this.options = _objectSpread({\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: function onChange() {},\n      measureElement: measureElement,\n      initialRect: {\n        width: 0,\n        height: 0\n      },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: \"data-index\",\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      isRtl: false,\n      useScrollendEvent: true\n    }, opts2);\n  };\n  this.notify = function (sync) {\n    var _a, _b;\n    (_b = (_a = _this.options).onChange) == null ? void 0 : _b.call(_a, _this, sync);\n  };\n  this.maybeNotify = memo(function () {\n    _this.calculateRange();\n    return [_this.isScrolling, _this.range ? _this.range.startIndex : null, _this.range ? _this.range.endIndex : null];\n  }, function (isScrolling) {\n    _this.notify(isScrolling);\n  }, {\n    key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n    debug: function debug() {\n      return _this.options.debug;\n    },\n    initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]\n  });\n  this.cleanup = function () {\n    _this.unsubs.filter(Boolean).forEach(function (d) {\n      return d();\n    });\n    _this.unsubs = [];\n    _this.observer.disconnect();\n    _this.scrollElement = null;\n    _this.targetWindow = null;\n  };\n  this._didMount = function () {\n    return function () {\n      _this.cleanup();\n    };\n  };\n  this._willUpdate = function () {\n    var _a;\n    var scrollElement = _this.options.enabled ? _this.options.getScrollElement() : null;\n    if (_this.scrollElement !== scrollElement) {\n      _this.cleanup();\n      if (!scrollElement) {\n        _this.maybeNotify();\n        return;\n      }\n      _this.scrollElement = scrollElement;\n      if (_this.scrollElement && \"ownerDocument\" in _this.scrollElement) {\n        _this.targetWindow = _this.scrollElement.ownerDocument.defaultView;\n      } else {\n        var _ref5;\n        _this.targetWindow = (_ref5 = (_a = _this.scrollElement) == null ? void 0 : _a.window) !== null && _ref5 !== void 0 ? _ref5 : null;\n      }\n      _this.elementsCache.forEach(function (cached) {\n        _this.observer.observe(cached);\n      });\n      _this._scrollToOffset(_this.getScrollOffset(), {\n        adjustments: void 0,\n        behavior: void 0\n      });\n      _this.unsubs.push(_this.options.observeElementRect(_this, function (rect) {\n        _this.scrollRect = rect;\n        _this.maybeNotify();\n      }));\n      _this.unsubs.push(_this.options.observeElementOffset(_this, function (offset, isScrolling) {\n        _this.scrollAdjustments = 0;\n        _this.scrollDirection = isScrolling ? _this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n        _this.scrollOffset = offset;\n        _this.isScrolling = isScrolling;\n        _this.maybeNotify();\n      }));\n    }\n  };\n  this.getSize = function () {\n    var _this$scrollRect;\n    if (!_this.options.enabled) {\n      _this.scrollRect = null;\n      return 0;\n    }\n    _this.scrollRect = (_this$scrollRect = _this.scrollRect) !== null && _this$scrollRect !== void 0 ? _this$scrollRect : _this.options.initialRect;\n    return _this.scrollRect[_this.options.horizontal ? \"width\" : \"height\"];\n  };\n  this.getScrollOffset = function () {\n    var _this$scrollOffset;\n    if (!_this.options.enabled) {\n      _this.scrollOffset = null;\n      return 0;\n    }\n    _this.scrollOffset = (_this$scrollOffset = _this.scrollOffset) !== null && _this$scrollOffset !== void 0 ? _this$scrollOffset : typeof _this.options.initialOffset === \"function\" ? _this.options.initialOffset() : _this.options.initialOffset;\n    return _this.scrollOffset;\n  };\n  this.getFurthestMeasurement = function (measurements, index) {\n    var furthestMeasurementsFound = /* @__PURE__ */new Map();\n    var furthestMeasurements = /* @__PURE__ */new Map();\n    for (var m = index - 1; m >= 0; m--) {\n      var measurement = measurements[m];\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue;\n      }\n      var previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n      if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n        furthestMeasurements.set(measurement.lane, measurement);\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true);\n      }\n      if (furthestMeasurementsFound.size === _this.options.lanes) {\n        break;\n      }\n    }\n    return furthestMeasurements.size === _this.options.lanes ? Array.from(furthestMeasurements.values()).sort(function (a, b) {\n      if (a.end === b.end) {\n        return a.index - b.index;\n      }\n      return a.end - b.end;\n    })[0] : void 0;\n  };\n  this.getMeasurementOptions = memo(function () {\n    return [_this.options.count, _this.options.paddingStart, _this.options.scrollMargin, _this.options.getItemKey, _this.options.enabled];\n  }, function (count, paddingStart, scrollMargin, getItemKey, enabled) {\n    _this.pendingMeasuredCacheIndexes = [];\n    return {\n      count: count,\n      paddingStart: paddingStart,\n      scrollMargin: scrollMargin,\n      getItemKey: getItemKey,\n      enabled: enabled\n    };\n  }, {\n    key: false\n  });\n  this.getMeasurements = memo(function () {\n    return [_this.getMeasurementOptions(), _this.itemSizeCache];\n  }, function (_ref6, itemSizeCache) {\n    var count = _ref6.count,\n      paddingStart = _ref6.paddingStart,\n      scrollMargin = _ref6.scrollMargin,\n      getItemKey = _ref6.getItemKey,\n      enabled = _ref6.enabled;\n    if (!enabled) {\n      _this.measurementsCache = [];\n      _this.itemSizeCache.clear();\n      return [];\n    }\n    if (_this.measurementsCache.length === 0) {\n      _this.measurementsCache = _this.options.initialMeasurementsCache;\n      _this.measurementsCache.forEach(function (item) {\n        _this.itemSizeCache.set(item.key, item.size);\n      });\n    }\n    var min = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _toConsumableArray(_this.pendingMeasuredCacheIndexes)) : 0;\n    _this.pendingMeasuredCacheIndexes = [];\n    var measurements = _this.measurementsCache.slice(0, min);\n    for (var i = min; i < count; i++) {\n      var key = getItemKey(i);\n      var furthestMeasurement = _this.options.lanes === 1 ? measurements[i - 1] : _this.getFurthestMeasurement(measurements, i);\n      var start = furthestMeasurement ? furthestMeasurement.end + _this.options.gap : paddingStart + scrollMargin;\n      var measuredSize = itemSizeCache.get(key);\n      var size = typeof measuredSize === \"number\" ? measuredSize : _this.options.estimateSize(i);\n      var end = start + size;\n      var lane = furthestMeasurement ? furthestMeasurement.lane : i % _this.options.lanes;\n      measurements[i] = {\n        index: i,\n        start: start,\n        size: size,\n        end: end,\n        key: key,\n        lane: lane\n      };\n    }\n    _this.measurementsCache = measurements;\n    return measurements;\n  }, {\n    key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.calculateRange = memo(function () {\n    return [_this.getMeasurements(), _this.getSize(), _this.getScrollOffset()];\n  }, function (measurements, outerSize, scrollOffset) {\n    return _this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n      measurements: measurements,\n      outerSize: outerSize,\n      scrollOffset: scrollOffset\n    }) : null;\n  }, {\n    key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.getIndexes = memo(function () {\n    return [_this.options.rangeExtractor, _this.calculateRange(), _this.options.overscan, _this.options.count];\n  }, function (rangeExtractor, range, overscan, count) {\n    return range === null ? [] : rangeExtractor({\n      startIndex: range.startIndex,\n      endIndex: range.endIndex,\n      overscan: overscan,\n      count: count\n    });\n  }, {\n    key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.indexFromElement = function (node) {\n    var attributeName = _this.options.indexAttribute;\n    var indexStr = node.getAttribute(attributeName);\n    if (!indexStr) {\n      console.warn(\"Missing attribute name '\".concat(attributeName, \"={index}' on measured element.\"));\n      return -1;\n    }\n    return parseInt(indexStr, 10);\n  };\n  this._measureElement = function (node, entry) {\n    var index = _this.indexFromElement(node);\n    var item = _this.measurementsCache[index];\n    if (!item) {\n      return;\n    }\n    var key = item.key;\n    var prevNode = _this.elementsCache.get(key);\n    if (prevNode !== node) {\n      if (prevNode) {\n        _this.observer.unobserve(prevNode);\n      }\n      _this.observer.observe(node);\n      _this.elementsCache.set(key, node);\n    }\n    if (node.isConnected) {\n      _this.resizeItem(index, _this.options.measureElement(node, entry, _this));\n    }\n  };\n  this.resizeItem = function (index, size) {\n    var _this$itemSizeCache$g;\n    var item = _this.measurementsCache[index];\n    if (!item) {\n      return;\n    }\n    var itemSize = (_this$itemSizeCache$g = _this.itemSizeCache.get(item.key)) !== null && _this$itemSizeCache$g !== void 0 ? _this$itemSizeCache$g : item.size;\n    var delta = size - itemSize;\n    if (delta !== 0) {\n      if (_this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? _this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, _this) : item.start < _this.getScrollOffset() + _this.scrollAdjustments) {\n        if (process.env.NODE_ENV !== \"production\" && _this.options.debug) {\n          console.info(\"correction\", delta);\n        }\n        _this._scrollToOffset(_this.getScrollOffset(), {\n          adjustments: _this.scrollAdjustments += delta,\n          behavior: void 0\n        });\n      }\n      _this.pendingMeasuredCacheIndexes.push(item.index);\n      _this.itemSizeCache = new Map(_this.itemSizeCache.set(item.key, size));\n      _this.notify(false);\n    }\n  };\n  this.measureElement = function (node) {\n    if (!node) {\n      _this.elementsCache.forEach(function (cached, key) {\n        if (!cached.isConnected) {\n          _this.observer.unobserve(cached);\n          _this.elementsCache[\"delete\"](key);\n        }\n      });\n      return;\n    }\n    _this._measureElement(node, void 0);\n  };\n  this.getVirtualItems = memo(function () {\n    return [_this.getIndexes(), _this.getMeasurements()];\n  }, function (indexes, measurements) {\n    var virtualItems = [];\n    for (var k = 0, len = indexes.length; k < len; k++) {\n      var i = indexes[k];\n      var measurement = measurements[i];\n      virtualItems.push(measurement);\n    }\n    return virtualItems;\n  }, {\n    key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.getVirtualItemForOffset = function (offset) {\n    var measurements = _this.getMeasurements();\n    if (measurements.length === 0) {\n      return void 0;\n    }\n    return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, function (index) {\n      return notUndefined(measurements[index]).start;\n    }, offset)]);\n  };\n  this.getOffsetForAlignment = function (toOffset, align) {\n    var size = _this.getSize();\n    var scrollOffset = _this.getScrollOffset();\n    if (align === \"auto\") {\n      if (toOffset <= scrollOffset) {\n        align = \"start\";\n      } else if (toOffset >= scrollOffset + size) {\n        align = \"end\";\n      } else {\n        align = \"start\";\n      }\n    }\n    if (align === \"start\") {\n      toOffset = toOffset;\n    } else if (align === \"end\") {\n      toOffset = toOffset - size;\n    } else if (align === \"center\") {\n      toOffset = toOffset - size / 2;\n    }\n    var scrollSizeProp = _this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n    var scrollSize = _this.scrollElement ? \"document\" in _this.scrollElement ? _this.scrollElement.document.documentElement[scrollSizeProp] : _this.scrollElement[scrollSizeProp] : 0;\n    var maxOffset = scrollSize - size;\n    return Math.max(Math.min(maxOffset, toOffset), 0);\n  };\n  this.getOffsetForIndex = function (index) {\n    var align = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n    index = Math.max(0, Math.min(index, _this.options.count - 1));\n    var item = _this.measurementsCache[index];\n    if (!item) {\n      return void 0;\n    }\n    var size = _this.getSize();\n    var scrollOffset = _this.getScrollOffset();\n    if (align === \"auto\") {\n      if (item.end >= scrollOffset + size - _this.options.scrollPaddingEnd) {\n        align = \"end\";\n      } else if (item.start <= scrollOffset + _this.options.scrollPaddingStart) {\n        align = \"start\";\n      } else {\n        return [scrollOffset, align];\n      }\n    }\n    var toOffset = align === \"end\" ? item.end + _this.options.scrollPaddingEnd : item.start - _this.options.scrollPaddingStart;\n    return [_this.getOffsetForAlignment(toOffset, align), align];\n  };\n  this.isDynamicMode = function () {\n    return _this.elementsCache.size > 0;\n  };\n  this.cancelScrollToIndex = function () {\n    if (_this.scrollToIndexTimeoutId !== null && _this.targetWindow) {\n      _this.targetWindow.clearTimeout(_this.scrollToIndexTimeoutId);\n      _this.scrollToIndexTimeoutId = null;\n    }\n  };\n  this.scrollToOffset = function (toOffset) {\n    var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref7$align = _ref7.align,\n      align = _ref7$align === void 0 ? \"start\" : _ref7$align,\n      behavior = _ref7.behavior;\n    _this.cancelScrollToIndex();\n    if (behavior === \"smooth\" && _this.isDynamicMode()) {\n      console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n    }\n    _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), {\n      adjustments: void 0,\n      behavior: behavior\n    });\n  };\n  this.scrollToIndex = function (index) {\n    var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref8$align = _ref8.align,\n      initialAlign = _ref8$align === void 0 ? \"auto\" : _ref8$align,\n      behavior = _ref8.behavior;\n    index = Math.max(0, Math.min(index, _this.options.count - 1));\n    _this.cancelScrollToIndex();\n    if (behavior === \"smooth\" && _this.isDynamicMode()) {\n      console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n    }\n    var offsetAndAlign = _this.getOffsetForIndex(index, initialAlign);\n    if (!offsetAndAlign) return;\n    var _offsetAndAlign = _slicedToArray(offsetAndAlign, 2),\n      offset = _offsetAndAlign[0],\n      align = _offsetAndAlign[1];\n    _this._scrollToOffset(offset, {\n      adjustments: void 0,\n      behavior: behavior\n    });\n    if (behavior !== \"smooth\" && _this.isDynamicMode() && _this.targetWindow) {\n      _this.scrollToIndexTimeoutId = _this.targetWindow.setTimeout(function () {\n        _this.scrollToIndexTimeoutId = null;\n        var elementInDOM = _this.elementsCache.has(_this.options.getItemKey(index));\n        if (elementInDOM) {\n          var _notUndefined = notUndefined(_this.getOffsetForIndex(index, align)),\n            _notUndefined2 = _slicedToArray(_notUndefined, 1),\n            latestOffset = _notUndefined2[0];\n          if (!approxEqual(latestOffset, _this.getScrollOffset())) {\n            _this.scrollToIndex(index, {\n              align: align,\n              behavior: behavior\n            });\n          }\n        } else {\n          _this.scrollToIndex(index, {\n            align: align,\n            behavior: behavior\n          });\n        }\n      });\n    }\n  };\n  this.scrollBy = function (delta) {\n    var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      behavior = _ref9.behavior;\n    _this.cancelScrollToIndex();\n    if (behavior === \"smooth\" && _this.isDynamicMode()) {\n      console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n    }\n    _this._scrollToOffset(_this.getScrollOffset() + delta, {\n      adjustments: void 0,\n      behavior: behavior\n    });\n  };\n  this.getTotalSize = function () {\n    var _a;\n    var measurements = _this.getMeasurements();\n    var end;\n    if (measurements.length === 0) {\n      end = _this.options.paddingStart;\n    } else {\n      var _ref10;\n      end = _this.options.lanes === 1 ? (_ref10 = (_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) !== null && _ref10 !== void 0 ? _ref10 : 0 : Math.max.apply(Math, _toConsumableArray(measurements.slice(-_this.options.lanes).map(function (m) {\n        return m.end;\n      })));\n    }\n    return Math.max(end - _this.options.scrollMargin + _this.options.paddingEnd, 0);\n  };\n  this._scrollToOffset = function (offset, _ref11) {\n    var adjustments = _ref11.adjustments,\n      behavior = _ref11.behavior;\n    _this.options.scrollToFn(offset, {\n      behavior: behavior,\n      adjustments: adjustments\n    }, _this);\n  };\n  this.measure = function () {\n    _this.itemSizeCache = /* @__PURE__ */new Map();\n    _this.notify(false);\n  };\n  this.setOptions(opts);\n});\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange(_ref12) {\n  var measurements = _ref12.measurements,\n    outerSize = _ref12.outerSize,\n    scrollOffset = _ref12.scrollOffset;\n  var count = measurements.length - 1;\n  var getOffset = function getOffset(index) {\n    return measurements[index].start;\n  };\n  var startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  var endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return {\n    startIndex: startIndex,\n    endIndex: endIndex\n  };\n}\nexport { Virtualizer, approxEqual, debounce, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, notUndefined, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };","map":{"version":3,"names":["defaultKeyExtractor","index","defaultRangeExtractor","range","start","Math","max","startIndex","overscan","end","min","endIndex","count","arr","i","push","observeElementRect","instance","cb","element","scrollElement","targetWindow","handler","rect","width","height","round","getBoundingClientRect","ResizeObserver","observer","entries","entry","borderBoxSize","box","inlineSize","blockSize","observe","unobserve","addEventListenerOptions","passive","observeWindowRect","innerWidth","innerHeight","addEventListener","removeEventListener","supportsScrollend","window","observeElementOffset","offset","fallback","options","useScrollendEvent","debounce","isScrollingResetDelay","createHandler","isScrolling","_instance$options","horizontal","isRtl","endHandler","observeWindowOffset","measureElement","size","windowScroll","_ref","_ref$adjustments","adjustments","behavior","toOffset","_b","_a","scrollTo","call","_defineProperty","elementScroll","_ref2","_ref2$adjustments","Virtualizer","_createClass","opts","_this","_classCallCheck","unsubs","scrollToIndexTimeoutId","measurementsCache","itemSizeCache","Map","pendingMeasuredCacheIndexes","scrollRect","scrollOffset","scrollDirection","scrollAdjustments","elementsCache","_ro","get","forEach","_measureElement","target","disconnect","setOptions","opts2","Object","_ref3","_ref4","_slicedToArray","key","value","_objectSpread","debug","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","onChange","initialRect","scrollMargin","gap","indexAttribute","initialMeasurementsCache","lanes","enabled","notify","sync","maybeNotify","memo","calculateRange","process","env","NODE_ENV","initialDeps","cleanup","filter","Boolean","d","_didMount","_willUpdate","getScrollElement","ownerDocument","defaultView","_ref5","cached","_scrollToOffset","getScrollOffset","getSize","_this$scrollRect","_this$scrollOffset","getFurthestMeasurement","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","has","lane","previousFurthestMeasurement","set","Array","from","values","sort","a","b","getMeasurementOptions","getMeasurements","_ref6","clear","length","item","apply","_toConsumableArray","slice","furthestMeasurement","measuredSize","estimateSize","outerSize","getIndexes","indexFromElement","node","attributeName","indexStr","getAttribute","console","warn","concat","parseInt","prevNode","isConnected","resizeItem","_this$itemSizeCache$g","itemSize","delta","shouldAdjustScrollPositionOnItemSizeChange","info","getVirtualItems","indexes","virtualItems","k","len","getVirtualItemForOffset","notUndefined","findNearestBinarySearch","getOffsetForAlignment","align","scrollSizeProp","scrollSize","document","documentElement","maxOffset","getOffsetForIndex","arguments","undefined","isDynamicMode","cancelScrollToIndex","clearTimeout","scrollToOffset","_ref7","_ref7$align","scrollToIndex","_ref8","_ref8$align","initialAlign","offsetAndAlign","_offsetAndAlign","setTimeout","elementInDOM","_notUndefined","_notUndefined2","latestOffset","approxEqual","scrollBy","_ref9","getTotalSize","_ref10","map","_ref11","scrollToFn","measure","low","high","getCurrentValue","middle","currentValue","_ref12","getOffset"],"sources":["../../src/index.ts"],"sourcesContent":["import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string | bigint\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(element.getBoundingClientRect())\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const entry = entries[0]\n    if (entry?.borderBoxSize) {\n      const box = entry.borderBoxSize[0]\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize })\n        return\n      }\n    }\n    handler(element.getBoundingClientRect())\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\ntype ObserveOffsetCallBack = (offset: number, isScrolling: boolean) => void\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    const { horizontal, isRtl } = instance.options\n    offset = horizontal\n      ? element['scrollLeft'] * ((isRtl && -1) || 1)\n      : element['scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n    element.removeEventListener('scrollend', endHandler)\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n    element.removeEventListener('scrollend', endHandler)\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: ObserveOffsetCallBack,\n  ) => void | (() => void)\n  // Optional\n  debug?: boolean\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem>\n  lanes?: number\n  isScrollingResetDelay?: number\n  useScrollendEvent?: boolean\n  enabled?: boolean\n  isRtl?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  private scrollToIndexTimeoutId: number | null = null\n  measurementsCache: Array<VirtualItem> = []\n  private itemSizeCache = new Map<Key, number>()\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          this._measureElement(entry.target as TItemElement, entry)\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => {\n        get()?.disconnect()\n        _ro = null\n      },\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      isRtl: false,\n      useScrollendEvent: true,\n      ...opts,\n    }\n  }\n\n  private notify = (sync: boolean) => {\n    this.options.onChange?.(this, sync)\n  }\n\n  private maybeNotify = memo(\n    () => {\n      this.calculateRange()\n\n      return [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ]\n    },\n    (isScrolling) => {\n      this.notify(isScrolling)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'maybeNotify',\n      debug: () => this.options.debug,\n      initialDeps: [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ] as [boolean, number | null, number | null],\n    },\n  )\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.observer.disconnect()\n    this.scrollElement = null\n    this.targetWindow = null\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.maybeNotify()\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this.elementsCache.forEach((cached) => {\n        this.observer.observe(cached)\n      })\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.maybeNotify()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n          this.isScrolling = isScrolling\n\n          this.maybeNotify()\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n      this.pendingMeasuredCacheIndexes = []\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        return []\n      }\n\n      if (this.measurementsCache.length === 0) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n\n        const furthestMeasurement =\n          this.options.lanes === 1\n            ? measurements[i - 1]\n            : this.getFurthestMeasurement(measurements, i)\n\n        const start = furthestMeasurement\n          ? furthestMeasurement.end + this.options.gap\n          : paddingStart + scrollMargin\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        const lane = furthestMeasurement\n          ? furthestMeasurement.lane\n          : i % this.options.lanes\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n        }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],\n    (measurements, outerSize, scrollOffset) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  private getIndexes = memo(\n    () => [\n      this.options.rangeExtractor,\n      this.calculateRange(),\n      this.options.overscan,\n      this.options.count,\n    ],\n    (rangeExtractor, range, overscan, count) => {\n      return range === null\n        ? []\n        : rangeExtractor({\n            startIndex: range.startIndex,\n            endIndex: range.endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const index = this.indexFromElement(node)\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const key = item.key\n    const prevNode = this.elementsCache.get(key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(key, node)\n    }\n\n    if (node.isConnected) {\n      this.resizeItem(index, this.options.measureElement(node, entry, this))\n    }\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      this.elementsCache.forEach((cached, key) => {\n        if (!cached.isConnected) {\n          this.observer.unobserve(cached)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualItems',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (toOffset: number, align: ScrollAlignment) => {\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start'\n      } else if (toOffset >= scrollOffset + size) {\n        align = 'end'\n      } else {\n        align = 'start'\n      }\n    }\n\n    if (align === 'start') {\n      toOffset = toOffset\n    } else if (align === 'end') {\n      toOffset = toOffset - size\n    } else if (align === 'center') {\n      toOffset = toOffset - size / 2\n    }\n\n    const scrollSizeProp = this.options.horizontal\n      ? 'scrollWidth'\n      : 'scrollHeight'\n    const scrollSize = this.scrollElement\n      ? 'document' in this.scrollElement\n        ? this.scrollElement.document.documentElement[scrollSizeProp]\n        : this.scrollElement[scrollSizeProp]\n      : 0\n\n    const maxOffset = scrollSize - size\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [this.getOffsetForAlignment(toOffset, align), align] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  private cancelScrollToIndex = () => {\n    if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n      this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId)\n      this.scrollToIndexTimeoutId = null\n    }\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    const offsetAndAlign = this.getOffsetForIndex(index, initialAlign)\n    if (!offsetAndAlign) return\n\n    const [offset, align] = offsetAndAlign\n\n    this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n    if (behavior !== 'smooth' && this.isDynamicMode() && this.targetWindow) {\n      this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        this.scrollToIndexTimeoutId = null\n\n        const elementInDOM = this.elementsCache.has(\n          this.options.getItemKey(index),\n        )\n\n        if (elementInDOM) {\n          const [latestOffset] = notUndefined(\n            this.getOffsetForIndex(index, align),\n          )\n\n          if (!approxEqual(latestOffset, this.getScrollOffset())) {\n            this.scrollToIndex(index, { align, behavior })\n          }\n        } else {\n          this.scrollToIndex(index, { align, behavior })\n        }\n      })\n    }\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else {\n      // If lanes is 1, use the last measurement's end, otherwise find the maximum end value among all measurements\n      end =\n        this.options.lanes === 1\n          ? (measurements[measurements.length - 1]?.end ?? 0)\n          : Math.max(\n              ...measurements.slice(-this.options.lanes).map((m) => m.end),\n            )\n    }\n\n    return Math.max(\n      end - this.options.scrollMargin + this.options.paddingEnd,\n      0,\n    )\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.notify(false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: Array<VirtualItem>\n  outerSize: number\n  scrollOffset: number\n}) {\n  const count = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset)\n  let endIndex = startIndex\n\n  while (\n    endIndex < count &&\n    measurements[endIndex]!.end < scrollOffset + outerSize\n  ) {\n    endIndex++\n  }\n\n  return { startIndex, endIndex }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}